import { ParseStrategy } from './strategies/ParseStrategy';
import Base62 from './base62';
import { GRID_LENGTH, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';

/**
 * 策略链解析器（统一入口+动态注册+自动匹配策略）
 */
export class SudokuParser {
  constructor() {
    // 维护策略列表（按注册顺序尝试解析）
    this.strategies = [];
  }

  /**
   * 注册解析策略（新增解析方式只需调用此方法）
   * @param {ParseStrategy} strategy - 策略实例
   * @returns {SudokuParser} 自身实例（链式调用）
   */
  registerStrategy(strategy) {
    if (!(strategy instanceof ParseStrategy)) {
      throw new Error('必须传入ParseStrategy的子类实例');
    }
    this.strategies.push(strategy);
    return this; // 支持链式注册：parser.register(a).register(b)
  }

  /**
   * 统一解析入口（自动匹配策略）
   * @param {string} input - 输入内容（Sencode/URL/其他）
   * @returns {number[][]} 解析后的9x9网格
   * @throws {Error} 无任何策略能解析时抛出异常
   */
  parse(input) {
    
    // 遍历策略列表，依次尝试验证 解析
    for (const strategy of this.strategies) {
      if (strategy.validate(input)) {
        const grid = strategy.parse(input);
        if (grid) return grid; // 解析成功，返回网格
      }
    }

    // 无策略能解析
    throw new Error(`无法解析输入内容：${input}，未匹配到任何解析策略`);
  }

  /**
   * 验证输入是否能被任何策略解析
   * @param {string} input - 输入内容
   * @returns {boolean} true=能被某策略解析，false=无策略能解析
   */
  validate(input) {
    for (const strategy of this.strategies) {
      if (strategy.validate(input)) {
        return true; // 有策略能解析
      }
    }
    return false; // 无策略能解析
  }

  /**
   * @param {number[]} flatGrid
   * @returns {boolean}
   */
  static #shouldReverse(flatGrid) {
    for (let cell = 0; cell < GRID_LENGTH; cell++) {
      if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
        return false;
      } else if (flatGrid[cell] !== 0) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {number[][]} sudoku
   * @returns {string}
   */
  encode(sudoku) {
    /** @type number[] */
      const flatGrid = sudoku.flat();
    
      const reversed = SudokuParser.#shouldReverse(flatGrid);
      if (reversed) {
        // Reverse sudoku array
        flatGrid.reverse();
      }
    
      let structure = '';
      let numbers = '';
    
      for (let cell = 0; cell < GRID_LENGTH; cell++) {
        structure += (flatGrid[cell] === 0 ? '0' : '1');
    
        if (flatGrid[cell] > 0) {
          numbers += flatGrid[cell] - 1; // Subtract 1 so the number gets smaller
        }
      }
    
      return Base62.encode(BigInt('0b' + structure)) +
             (reversed ? SEPARATOR_REVERSE : SEPARATOR) +
             Base62.encode(BigInt(numbers));
    }

  /**
   * 清空所有策略（用于重置）
   */
  clearStrategies() {
    this.strategies = [];
  }
}

import { SencodeParseStrategy } from './strategies/SencodeParseStrategy';
import { UrlParseStrategy } from './strategies/UrlParseStrategy';
// 创建全局解析器
export const sudokuParser = (new SudokuParser()).registerStrategy(new SencodeParseStrategy()).registerStrategy(new UrlParseStrategy());
import { ParseStrategy } from '@sudoku/sudoku_parser/strategies/ParseStrategy';
import {
  SUDOKU_SIZE,
  SENCODE_SEPARATOR,
  SENCODE_SEPARATOR_REVERSE,
  GRID_LENGTH,
  GRID_COORDS,
  SENCODE_REGEX
} from '@sudoku/constants';
import Base62 from '@sudoku/sudoku_parser/base62';

export class SencodeParseStrategy extends ParseStrategy {
  /**
   * 验证：是否是合法的Sencode格式
   * @param {string} input
   * @returns {boolean}
   */
  validate(input) {
   return input && input.trim().length !== 0 && SENCODE_REGEX.test(input); // 复用原有验证逻辑
  }

  /**
   * 解析Sencode（验证通过才会执行）
   * @param {string} sencode
   * @returns {number[][]}
   */
  parse(sencode) {
    let grid = Array(SUDOKU_SIZE).fill(0).map(() => Array(SUDOKU_SIZE).fill(0));
    const reversed = sencode.indexOf(SENCODE_SEPARATOR_REVERSE) !== -1;
    const separator = reversed ? SENCODE_SEPARATOR_REVERSE : SENCODE_SEPARATOR;
    const [encodedStructure, encodedNumbers] = sencode.split(separator);

    // 原有Sencode解析逻辑（无改动）
    const structure = Base62.decode(encodedStructure)
      .toString(2)
      .padStart(GRID_LENGTH, '0');

    let numberCount = 0;
    for (let cell = 0; cell < GRID_LENGTH; cell++) {
      if (structure[cell] === '1') numberCount++;
    }

    let numbers = Base62.decode(encodedNumbers)
      .toString()
      .padStart(numberCount, '0')
      .split('');

    for (let cell = 0; cell < GRID_LENGTH; cell++) {
      if (structure[cell] === '1') {
        const [row, col] = GRID_COORDS[cell];
        grid[row][col] = Number(numbers.shift()) + 1;
      }
    }

    if (reversed) {
      grid = grid.reverse().map(row => row.reverse());
    }

    return grid;
  }
}
